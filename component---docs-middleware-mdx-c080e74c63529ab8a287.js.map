{"version":3,"sources":["webpack:///./docs/Middleware.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"uPAQaA,G,UAAe,S,qMAC5B,IAAMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,YAACJ,EAAD,eAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,cADR,cAGA,uBACA,4MAC2D,0BAAYC,WAAW,KAAvB,mBAD3D,mOAEA,gSACA,iLACA,iBAAQ,CACN,GAAM,yCADR,2CAGA,0HACA,+BACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,0JAUL,4BACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,+QAcL,iBAAQ,CACN,GAAM,gCADR,gCAGA,4IACA,sBACE,kBAAIA,WAAW,MAAf,mDACA,kBAAIA,WAAW,MAAf,mEAEF,6EACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,+GAOL,iBAAQ,CACN,GAAM,uBADR,uBAGA,mPACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,uO,mMAYTJ,EAAWK,gBAAiB","file":"component---docs-middleware-mdx-c080e74c63529ab8a287.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/ziggurat-web/ziggurat-web/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"middleware\"\n    }}>{`Middleware`}</h1>\n    <hr></hr>\n    <p>{`Ziggurat V3.0.0-alpha.3 (will be released in 3.0.0 stable version) introduced the support for middleware in Ziggurat.\nIn older versions of Ziggurat, the mapper-function passed to `}<inlineCode parentName=\"p\">{`(ziggurat/init)`}</inlineCode>{` would get the message as a parameter which was an object of Clojure PersistentHashMap. Ziggurat assumed that all messages read from Kafka were serialized using Protobuf and it would thus deserialize the message internally.`}</p>\n    <p>{`As the userbase of Ziggurat has grown and the problem space people are trying to tackle with Ziggurat has widened, we realize that this was a wrong assumption and so from this release Ziggurat will just pass the serialized message directly to the mapper-function.`}</p>\n    <p>{`We have provided a default middleware that replicates the logic (deserialization of proto) and thus users can use and thus have backward compatibility. `}</p>\n    <h2 {...{\n      \"id\": \"migration-from-2x---3x-for-middleware\"\n    }}>{`Migration from 2.x - 3.x for middleware`}</h2>\n    <p>{`All you have to do to migrate to the newer version is update the mapper-function. So, for example`}</p>\n    <p>{`Change`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-clojure\"\n      }}>{`;; 2.x\n(defn main-fn\n    [message]\n    (println message)\n    :success)\n  \n(ziggurat/main start-fn stop-fn {:stream-id {:handler-fn main-fn}})\n`}</code></pre>\n    <p>{`to `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-clojure\"\n      }}>{`;; 3.x\n(defn main-fn\n    [message]\n    (println message)\n    :success)\n\n(def handler-fn\n    (-> main-fn\n        (ziggurat.middleware.default/protobuf->hash protoClass :stream-id)))\n  \n(ziggurat/main start-fn stop-fn {:stream-id {:handler-fn handler-fn}})\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"defining-your-own-middleware\"\n    }}>{`Defining your own Middleware`}</h2>\n    <p>{`If you wish to define your own middleware function, ensure that the function follows these definition restrictions:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`The first argument should be a handler-function`}</li>\n      <li parentName=\"ul\">{`It should return a function that takes 1 argument: the message`}</li>\n    </ul>\n    <p>{`An example of a middleware that just logs a message:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-clojure\"\n      }}>{`(defn wrap-log-message [handler-fn]\n  (fn [message]\n    (log/info message)\n    (handler-fn message)))\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"chaining-middleware\"\n    }}>{`Chaining Middleware`}</h2>\n    <p>{`You can also chain multiple middleware functions to incorporate different behaviours. So for example if you wish to deserialize a message and then log it we can chain these middlewares on wrap your mapper-fn with them.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-clojure\"\n      }}>{`;; protobuf->hash is a default middleware that Ziggurat gives to deserialize proto\n(def handler-fn\n  (-> mapper-fn\n      (wrap-log-message)\n      (ziggurat.middleware.default/protobuf->hash protoClass :stream-id)))\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}