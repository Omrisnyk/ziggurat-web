(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{Y3Ov:function(e,t,a){"use strict";a.r(t),a.d(t,"_frontmatter",(function(){return l})),a.d(t,"default",(function(){return b}));var n=a("wx14"),i=a("zLVn"),o=(a("q1tI"),a("7ljp")),r=a("hhGP"),l=(a("qKvR"),{});void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/retries-and-queues.mdx"}});var s={_frontmatter:l},c=r.a;function b(e){var t=e.components,a=Object(i.a)(e,["components"]);return Object(o.b)(c,Object(n.a)({},s,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"retries-and-queues"},"Retries and Queues"),Object(o.b)("hr",null),Object(o.b)("h2",{id:"content"},"Content"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"#introduction"}),"Introduction")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"#topology-of-the-queues"}),"Topology of the Queues")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"#queue-stats"}),"Queue Stats")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"#peaking-and-replaying-deadset"}),"Peaking & Replaying DeadSet")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",Object(n.a)({parentName:"li"},{href:"#what-happens-when-the-actor-goes-down"}),"What happens when the actor goes down"))),Object(o.b)("h2",{id:"introduction"},"Introduction"),Object(o.b)("p",null,"When processing a stream of events, there are many times where the processing might fail.\nEither because of the issue in the function logic or some issue downstream."),Object(o.b)("p",null,"In the first case, we don't want to lose the message. In second, we\npossibly want to retry the message and expect that the downstream\nservice might be down intermittently."),Object(o.b)("p",null,"This acts as a foundation of the requirement of a queue to fall back to."),Object(o.b)("p",null,"Ziggurat provides Retry-As-A-Service, which means your messages\nautomatically get queued on failures."),Object(o.b)("p",null,"Let's take a deep dive"),Object(o.b)("h2",{id:"topology-of-queues"},"Topology of Queues"),Object(o.b)("p",null,"Every application using ziggurat creates 3 dedicated queues in Rabbitmq:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},Object(o.b)("strong",{parentName:"p"},"Delayed Queue:"),"\nWhen an error occurs for a message in the mapper-function. The message is put in the delay queue with a TTL (can be set in the config).\nThey wait in the queue until the TTL expires. Then they are put into the instant queue.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},Object(o.b)("strong",{parentName:"p"},"Instant Queue:"),"\nThe retry logic in ziggurat reads messages from the instant queue and retries them.\nIf the retry fails again it puts the message back into the delay queue with the predefined TTL.\nThis happens 3(or however many times the RETRY_COUNT config defines it). If the message still does not succeed it is put into the Dead-set queue."))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"This results in a linear backoff for the retires of the same message.")),Object(o.b)("ol",{start:3},Object(o.b)("li",{parentName:"ol"},Object(o.b)("strong",{parentName:"li"},"Dead Set Queue:"),"\nMessages are put into the dead set when they fail to successfully process even after however many times the RETRY_COUNT defines it.\nYou can retry messages from the dead set queue by making an API call to the actor.")),Object(o.b)("h2",{id:"peaking-replaying-and-deleting-deadset"},"Peaking, Replaying and Deleting DeadSet"),Object(o.b)("p",null,"DeadSet is the last place a message can reach in its life cycle because of failures.\nZiggurat does not automatically retry the messages in the dead set as it could be due to a bug in the mapper-function and the\nuser can trigger the retry of messages once the problem has been fixed."),Object(o.b)("p",null,"There are three built-in APIs to view and trigger retry on the DeadSet:"),Object(o.b)("p",null,"  Assuming your stream routes are defined as follows:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-clojure"}),"  (ziggurat/main start-fn stop-fn {:stream-id-1 {:handler-fn main-fn}\n                                   :stream-id-2 {:handler-fn (fn [] :outbound-channel)\n                                                 :outbound-channel main-fn}})\n")),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Peek: A GET API where you can fetch ",Object(o.b)("inlineCode",{parentName:"li"},"N")," messages from the deadset to see which message went in.")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"For multi-stream applications (that read from multiple kafka streams)",Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"curl -X GET \\\n  'http://localhost:8010/v1/dead_set?count=10&topic-entity=stream-id-1'\n"))),Object(o.b)("li",{parentName:"ul"},"For multi-stream applications with channels",Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),"curl -X GET \\\n  'http://localhost:8010/v1/dead_set?count=10&topic-entity=stream-id-2&channel=outbound-channel'\n")),"where"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"10")," is the number of messages you wish to view"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"8010")," is the port that is listening to the HTTP requests"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"stream-id-*")," is the topic entity of your actor"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"outbound-channel")," is the channel on topic-entity ",Object(o.b)("inlineCode",{parentName:"li"},"stream-id-2"))),Object(o.b)("ol",{start:2},Object(o.b)("li",{parentName:"ol"},"Replay: A POST API where you can select ",Object(o.b)("inlineCode",{parentName:"li"},"N")," messages to be retried from the DeadSet.")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"For multi-stream applications (that read from multiple kafka streams)",Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),'curl -X POST \\\n  http://localhost:8010/v1/dead_set/replay \\\n  -H \'content-type: application/json\' \\\n  -d \'{"count":"10", "topic_entity":"stream-id-1"}\'\n'))),Object(o.b)("li",{parentName:"ul"},"For multi-stream applications with channels",Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),'curl -X POST \\\n  http://localhost:8010/v1/dead_set/replay \\\n  -H \'content-type: application/json\' \\\n  -d \'{"count":"10", "topic_entity":"stream-id-2", "channel": "outbound-channel"}\'\n')),"where"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"10")," is the number of messages you wish to retry"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"8010")," is the port that is listening to the HTTP requests"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"stream-id-*")," is the topic entity of your actor"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"outbound-channel")," is the channel on topic-entity ",Object(o.b)("inlineCode",{parentName:"li"},"stream-id-2"))),Object(o.b)("ol",{start:3},Object(o.b)("li",{parentName:"ol"},"Delete: A DELETE API where you delete the last ",Object(o.b)("inlineCode",{parentName:"li"},"N")," messages from the\nDeadSet queue.")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("em",{parentName:"p"},"This feature is available in ziggurat version >= ",Object(o.b)("inlineCode",{parentName:"em"},"2.8.0")))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"For deleting messages from an actor without channels"),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),'curl -X DELETE \\\nhttp://localhost:8010/v1/dead_set \\\n-H \'content-type: application/json\' \\\n-d \'{"count":"10", "topic-entity":"booking"}\'\n'))),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"For deleteing messages from an actor with channels"),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(n.a)({parentName:"pre"},{}),'curl -X DELETE \\\nhttp://localhost:8010/v1/dead_set \\\n-H \'content-type: application/json\' \\\n-d \'{"count":"10", "topic-entity":"booking", "channel": "dss-outbound"}\'\n')),Object(o.b)("p",{parentName:"li"},"where"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"10")," is the number of messages you wish to retry"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"8010")," is the port that is listening to the HTTP requests"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"booking")," is the topic entity of your actor"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"dss-outbound")," is the channel on topic-entity ",Object(o.b)("inlineCode",{parentName:"li"},"booking"))))),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"You cannot get/replay/delete a specific message")),Object(o.b)("h2",{id:"what-happens-when-the-actor-goes-down"},"What happens when the actor goes down"),Object(o.b)("p",null,"When the actor goes down all the processing stops. So there won't be any new messages getting read from Kafka.\nNo new messages will come into any of the queues."))}void 0!==b&&b&&b===Object(b)&&Object.isExtensible(b)&&!b.hasOwnProperty("__filemeta")&&Object.defineProperty(b,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/retries-and-queues.mdx"}}),b.isMDXComponent=!0}}]);
//# sourceMappingURL=component---docs-retries-and-queues-mdx-19b7fbb89cfc771e2400.js.map